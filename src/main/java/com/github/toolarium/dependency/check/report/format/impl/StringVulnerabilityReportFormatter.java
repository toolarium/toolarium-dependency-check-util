/*
 * StringVulnerabilityReportFormatter.java
 *
 * Copyright by toolarium, all rights reserved.
 */
package com.github.toolarium.dependency.check.report.format.impl;

import com.github.toolarium.common.util.StringUtil;
import com.github.toolarium.common.util.TextUtil;
import com.github.toolarium.dependency.check.report.Dependency;
import com.github.toolarium.dependency.check.report.DependencyArtifact;
import com.github.toolarium.dependency.check.report.Vulnerability;
import com.github.toolarium.dependency.check.report.VulnerabilityReport;
import com.github.toolarium.dependency.check.report.format.IVulnerabilityReportFormatter;


/**
 * Implements a string based {@link IVulnerabilityReportFormatter}.
 * 
 * @author patrick
 */
public class StringVulnerabilityReportFormatter extends AbstractVulnerabilityReportFormatter<String> {
    private static final String CVE_TITLE = "CVE";
    private static final String SEVERITY_TITLE = "Severity";
    private static final String INCLUDED_BY_TITLE = "Included";
    private static final String DEPENDECY_URL_TITLE = "Dep.-Ref";
    private static final String VULNERABILITY_REFERENCE_URL_TITLE = "Vul.-Ref";
    private static final String REASON_TITLE = "Reason";
    private boolean enableConfidence = true;
    private boolean enableReason = true;
    private boolean enableDependencyUrl = false;
    private boolean enableVulnerabilityUrl = true;
    private String configurationStart = ">";
    private String entryStart = "+";
    private String subEntryStart = "-";
    private String indent = TextUtil.SPACE;
    private String contentStartSeparator = TextUtil.SPACE;
    private boolean breakUrl = false;
    private int maxTextLen = 120;
    private int titleMaxLen = 10;

    
    /**
     * Constructor for StringVulnerabilityReportFormatter
     */
    public StringVulnerabilityReportFormatter() {
    }

    
    /**
     * Get enable confidence
     *
     * @return is confidence enabled
     */
    public boolean getEnableConfidence() {
        return enableConfidence;
    }

    
    /**
     * Set enable confidence
     *
     * @param enableConfidence enable confidence
     * @return this object
     */
    public StringVulnerabilityReportFormatter setEnableConfidence(boolean enableConfidence) {
        this.enableConfidence = enableConfidence;
        return this;
    }

    
    /**
     * Get enable reason
     *
     * @return is reason enabled
     */
    public boolean getEnableReason() {
        return enableReason;
    }

    
    /**
     * Set enable reason
     *
     * @param enableReason enable reason
     * @return this object
     */
    public StringVulnerabilityReportFormatter setEnableReason(boolean enableReason) {
        this.enableReason = enableReason;
        return this;
    }

    
    /**
     * get enable dependency url
     *
     * @return is dependency url enabled
     */
    public boolean getEnableDependencyUrl() {
        return enableDependencyUrl;
    }

    
    /**
     * Set enable dependency url
     *
     * @param enableDependencyUrl enable dependency url
     * @return this object
     */
    public StringVulnerabilityReportFormatter setEnableDependencyUrl(boolean enableDependencyUrl) {
        this.enableDependencyUrl = enableDependencyUrl;
        return this;
    }

    
    /**
     * Get enable vulnerability url
     *
     * @return is url enabled
     */
    public boolean getEnableVulnerabilityUrl() {
        return enableVulnerabilityUrl;
    }

    
    /**
     * Set enable vulnerability url
     *
     * @param enableVulnerabilityUrl enable url
     * @return this object
     */
    public StringVulnerabilityReportFormatter setEnableVulnerabilityUrl(boolean enableVulnerabilityUrl) {
        this.enableVulnerabilityUrl = enableVulnerabilityUrl;
        return this;
    }

    
    /**
     * Get the configuration start header
     *
     * @return the configuration start header
     */
    public String getConfigurationStart() {
        return configurationStart;
    }

    
    /**
     * Set the configuration start header
     *
     * @param configurationStart the configuration start header
     * @return this object
     */
    public StringVulnerabilityReportFormatter setConfigurationStart(String configurationStart) {
        this.configurationStart = configurationStart;
        return this;
    }

    
    /**
     * Get the entry start header
     *
     * @return the entry start header
     */
    public String getEntryStart() {
        return entryStart;
    }

    
    /**
     * Set the entry start header
     *
     * @param entryStart the entry start header
     * @return this object
     */
    public StringVulnerabilityReportFormatter setEntryStart(String entryStart) {
        this.entryStart = entryStart;
        return this;
    }

    
    /**
     * Get the sub entry start header
     *
     * @return the sub entry start header
     */
    public String getSubEntryStart() {
        return subEntryStart;
    }

    
    /**
     * Set the sub entry start header
     *
     * @param subEntryStart the sub entry start header
     * @return this object
     */
    public StringVulnerabilityReportFormatter setSubEntryStart(String subEntryStart) {
        this.subEntryStart = subEntryStart;
        return this;
    }

    
    /**
     * Get the indent
     *
     * @return the indent
     */
    public String getIndent() {
        return indent;
    }

    
    /**
     * Set the indent
     *
     * @param indent the indent
     * @return this object
     */
    public StringVulnerabilityReportFormatter setIndent(String indent) {
        this.indent = indent;
        return this;
    }

    
    /**
     * Get the title max len
     *
     * @return the title max len
     */
    public int getTitleMaxLen() {
        return titleMaxLen;
    }

    
    /**
     * Set the title max len
     *
     * @param titleMaxLen the title max len
     * @return this object
     */
    public StringVulnerabilityReportFormatter setTitleMaxLen(int titleMaxLen) {
        this.titleMaxLen = titleMaxLen;
        return this;
    }

    
    /**
     * Get the max text len
     *
     * @return the max text len
     */
    public int getMaxTextLen() {
        return maxTextLen;
    }

    
    /**
     * Set the max text len
     *
     * @param maxTextLen the max text len
     * @return this object
     */
    public StringVulnerabilityReportFormatter setMaxTextLen(int maxTextLen) {
        this.maxTextLen = maxTextLen;
        return this;
    }

    
    /**
     * Get the content start separator
     *
     * @return the content start separator
     */
    public String getContentStartSeparator() {
        return contentStartSeparator;
    }

    
    /**
     * Set the content start separator
     *
     * @param contentStartSeparator the content start separator
     * @return this object
     */
    public StringVulnerabilityReportFormatter setContentStartSeparator(String contentStartSeparator) {
        this.contentStartSeparator = contentStartSeparator;
        return this;
    }

    
    /**
     * Get if urls should be break up into block text or not
     *
     * @return break urls, true or false
     */
    public boolean getBreakUrl() {
        return breakUrl;
    }

    
    /**
     * Define if urls should be break up into block text or not
     *
     * @param breakUrl true or false
     * @return this object
     */
    public StringVulnerabilityReportFormatter setBreakUrl(boolean breakUrl) {
        this.breakUrl = breakUrl;
        return this;
    }

    
    /**
     * @see com.github.toolarium.dependency.check.report.format.IVulnerabilityReportFormatter#format(com.github.toolarium.dependency.check.report.VulnerabilityReport, java.lang.String)
     */
    @Override
    public String format(VulnerabilityReport vulnerabilityReport, String configuration) { 
        if (!hasVulnerability(vulnerabilityReport, configuration)) {
            return null;
        }
        
        final StringBuilder dependencyIndent = createDependencyIndent();
        final StringBuilder entryIndent = createEntryIndent(dependencyIndent);
        final StringBuilder subEntryIndent = createSubEntryIndent(entryIndent);
        
        StringBuilder builder = new StringBuilder();
        builder.append(indent).append(configurationStart).append(contentStartSeparator).append(configurationName(configuration)).append(":");
        int lineLength = (subEntryIndent.length() + maxTextLen + titleMaxLen) - builder.length();
        if (lineLength > 0) {
            builder.append(StringUtil.getInstance().newString(TextUtil.SPACE, lineLength));
        }
        builder.append(TextUtil.NL);
        
        int counter = 0;
        
        for (Dependency dependency : vulnerabilityReport.getVulnerabilities(configuration)) {
            if (counter > 0) {
                builder.append(TextUtil.NL);
            }
            counter++;
            
            // add entry
            // ignore: vulnerability.getFilename();
            StringBuilder artefactHeader = new StringBuilder().append(indent).append(dependencyIndent).append(entryStart).append(contentStartSeparator).append(artefactName(dependency.getDependencyArtifact().toArtifactId())); 
            if (enableConfidence && exist(dependency.getConfidence())) {
                artefactHeader.append(confidence(dependency.getConfidence()));
            }

            lineLength = (subEntryIndent.length() + maxTextLen + titleMaxLen) - artefactHeader.length();
            if (lineLength > 0) {
                artefactHeader.append(StringUtil.getInstance().newString(TextUtil.SPACE, lineLength));
            }
            artefactHeader.append(TextUtil.NL);
            // ignore: vulnerability.getPackageDescription() & vulnerability.getPackageLicence();
            
            //builder.append(StringUtil.getInstance().newString(TextUtil.SPACE, (subEntryIndent.length() + maxTextLen + titleMaxLen) - indent.length() - dependencyIndent.length() - entryStart.length())).append(TextUtil.NL);
            
            builder.append(artefactHeader);

            // add cve list
            if (dependency != null && dependency.getVulnerabilityList() != null) {
                builder.append(createCveList(subEntryIndent, dependency)).append(TextUtil.NL);
            }

            // add severity
            if (dependency.getMostCrititcalVulnerability() != null) {
                builder.append(createSeverity(subEntryIndent, dependency.getMostCrititcalVulnerability())).append(TextUtil.NL);
            }

            // included by
            builder.append(createIncludedBy(subEntryIndent, dependency));

            // reason
            Vulnerability mostCrititcalVulnerability = dependency.getMostCrititcalVulnerability();
            if (enableReason) {
                if (mostCrititcalVulnerability != null && exist(mostCrititcalVulnerability.getDescription())) {
                    builder.append(TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(REASON_TITLE), titleMaxLen, new StringBuilder(reason(mostCrititcalVulnerability.getDescription())), maxTextLen)).append(TextUtil.NL);
                }
            }


            // url references
            if (enableDependencyUrl) {
                if (exist(dependency.getUrl())) {
                    if (breakUrl) {
                        builder.append(TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(DEPENDECY_URL_TITLE), titleMaxLen, new StringBuilder(url(dependency.getUrl())), maxTextLen)).append(TextUtil.NL);
                    } else {
                        builder.append(TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(DEPENDECY_URL_TITLE), titleMaxLen, new StringBuilder(), 0)).append(url(dependency.getUrl())).append(TextUtil.NL);
                    }
                }
            }
            
            if (enableVulnerabilityUrl) {
                if (mostCrititcalVulnerability != null && exist(mostCrititcalVulnerability.getUrl())) {
                    if (breakUrl) {
                        builder.append(TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(VULNERABILITY_REFERENCE_URL_TITLE), titleMaxLen, new StringBuilder(url(mostCrititcalVulnerability.getUrl())), maxTextLen)).append(TextUtil.NL);
                    } else {
                        builder.append(TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(VULNERABILITY_REFERENCE_URL_TITLE), titleMaxLen, new StringBuilder(), 0)).append(url(mostCrititcalVulnerability.getUrl())).append(TextUtil.NL);
                    }
                }
            }

    
            // software reference
            /*
            if (exist(vulnerability.getProjectReferenceList())) {
                for (String reference : vulnerability.getProjectReferenceList()) {
                    builder.append(header).append(reference).append(NL);
                }
            }
            */
        }
        
        return builder.toString();
    }

    
    /**
     * Create cve list
     * 
     * @param subEntryIndent the sub entry ident
     * @param dependency the dependency
     * @return the most critical vulnerability
     */
    protected StringBuilder createCveList(StringBuilder subEntryIndent, Dependency dependency) {
        final StringBuilder cveList = new StringBuilder();
        int i = 0;
        int cveTextLen = maxTextLen;
        int lineLength = 0;
        int diff =  0;
        int endOfLineCounter = 0;
        for (Vulnerability vulnerability : dependency.getVulnerabilityList()) {
            if (exist(vulnerability.getCve())) {
                final String cve = cve(vulnerability.getCve());
                if (i > 0) {
                    cveList.append(", ");
                    lineLength += 2;
                } else {
                    diff = (cve.length() - vulnerability.getCve().length());
                }
            
                cveList.append(cve);

                if ((lineLength + vulnerability.getCve().length()) < maxTextLen) {
                    lineLength += vulnerability.getCve().length();
                    endOfLineCounter++;
                }
                
                i++;
            }
        }
        cveTextLen += (endOfLineCounter * diff);
        return TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(CVE_TITLE), titleMaxLen, cveList, cveTextLen);
    }

    
    /**
     * Create severity
     * 
     * @param subEntryIndent the sub entry ident
     * @param vulnerability the vulnerability
     * @return the builder
     */
    protected StringBuilder createSeverity(StringBuilder subEntryIndent, Vulnerability vulnerability) {
        int severityLen = 0;
        if (exist(vulnerability.getSeverity())) {
            severityLen += vulnerability.getSeverity().length();
        }
        if (vulnerability.getScore() != null) {
            severityLen += vulnerability.getScore().toString().length() + 2;
        }
        if (exist(vulnerability.getSource())) {
            severityLen += vulnerability.getSource().length() + 2;
        }

        int sevrityTextLen = maxTextLen;
        final String severity = severity(vulnerability.getSeverity(), vulnerability.getScore(), vulnerability.getSource());
        sevrityTextLen += severity.length() - severityLen;
        StringBuilder builder = new StringBuilder();
        builder.append(severity);

        if (exist(vulnerability.getEndExcludingVersion())) {
            String endExcludingVersion = endExcludingVersion(vulnerability.getEndExcludingVersion());
            builder.append(endExcludingVersion);
            sevrityTextLen += endExcludingVersion.length() - (" -> fixed by " + vulnerability.getEndExcludingVersion()).length();
        }
        builder.append(TextUtil.NL);
        
        return TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(SEVERITY_TITLE), titleMaxLen, builder, sevrityTextLen);
    }
    
    
    /**
     * Create included by
     * 
     * @param subEntryIndent the sub entry ident
     * @param dependency the dependency
     * @return the builder
     */
    protected StringBuilder createIncludedBy(StringBuilder subEntryIndent, Dependency dependency) {
        StringBuilder builder = new StringBuilder();

        int includedByTextLen = maxTextLen;
        if (exist(dependency.getIncludedByReferenceList())) {
            int i = 0;
            for (DependencyArtifact d : dependency.getIncludedByReferenceList()) {
                if (i > 0) {
                    builder.append(", ");
                }
                
                final String includedBy = includedBy(d.getName(), d.getVersion());
                includedByTextLen += includedBy.length() - ("" + d.getName() + ":" + d.getVersion()).length();
                builder.append(includedBy);
                i++;
            }

            return TextUtil.getInstance().blockText(subEntryIndent, new StringBuilder(INCLUDED_BY_TITLE), titleMaxLen, builder, includedByTextLen).append(TextUtil.NL);
        }
        return builder;
    }
    
    
    /**
     * Create dependency indention
     * 
     * @return the prepared string builder
     */
    protected StringBuilder createDependencyIndent() {
        StringBuilder dependencyIndent = new StringBuilder();
        for (int i = 0; i < configurationStart.length() + contentStartSeparator.length(); i++) {
            dependencyIndent.append(TextUtil.SPACE);
        }
        
        return dependencyIndent;
    }


    /**
     * Create entry indention
     * 
     * @param dependencyIndent the depndency indention
     * @return the prepared string builder
     */
    protected StringBuilder createEntryIndent(StringBuilder dependencyIndent) {
        StringBuilder subEntryIndent = new StringBuilder();
        for (int i = 0; i < entryStart.length(); i++) {
            subEntryIndent.append(TextUtil.SPACE);
        }
        
        subEntryIndent.append(dependencyIndent).append(contentStartSeparator);
        return subEntryIndent;
    }

    
    /**
     * Create sub entry indention
     * 
     * @param entryIndent the entry indention
     * @return the prepared string builder
     */
    protected StringBuilder createSubEntryIndent(StringBuilder entryIndent) {
        return new StringBuilder().append(indent).append(entryIndent).append(subEntryStart).append(contentStartSeparator);
    }

    
    /**
     * Artifact id
     * 
     * @param artifactId the artifact id
     * @return the artifact id
     */
    protected String artefactName(String artifactId) {
        return artifactId;
    }


    /**
     * Configuration name
     * 
     * @param configuration the configuration name
     * @return the configuration name
     */
    protected String configurationName(String configuration) {
        return configuration;
    }
    

    /**
     * Confidence
     * 
     * @param confidence the confidence
     * @return the confidence
     */
    protected String confidence(String confidence) {
        return " (confidence:" + confidence + ")";
    }

    
    /**
     * Severity
     * 
     * @param severity the severity
     * @param score the score
     * @param source the source
     * @return the severity
     */
    protected String severity(String severity, Double score, String source) {
        
        StringBuilder builder = new StringBuilder();
        if (exist(severity)) {
            builder.append(severity);
        }

        if (score != null) {
            builder.append(", ").append(score);
        }

        if (exist(source)) {
            builder.append(", ").append(source);
        }
        
        return builder.toString();
    }

    
    /**
     * The cve
     * 
     * @param cve the cve
     * @return the cve
     */
    protected String cve(String cve) {
        return cve;
    }
    

    /**
     * Included by
     * 
     * @param includedBy included by
     * @param version the version
     * @return included by
     */
    protected String includedBy(String includedBy, String version) {
        return includedBy + ":" + version;
    }
    
    
    /**
     * End excluding version
     * 
     * @param version the end excluding version
     * @return included by
     */
    protected String endExcludingVersion(String version) {
        return " -> fixed by " + version;
    }


    /**
     * Url
     *
     * @param url the url
     * @return the url
     */
    protected String url(String url) {
        return url;
    }


    /**
     * reason
     *
     * @param reason the reson
     * @return the reson
     */
    protected String reason(String reason) {
        return reason;
    }
}
