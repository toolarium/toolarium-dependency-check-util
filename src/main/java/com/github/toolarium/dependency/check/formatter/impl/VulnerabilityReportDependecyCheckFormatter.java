/*
 * VulnerabilityDependecyCheckFormatter.java
 *
 * Copyright by toolarium, all rights reserved.
 */
package com.github.toolarium.dependency.check.formatter.impl;

import com.github.toolarium.dependency.check.DependencyCheckUtil;
import com.github.toolarium.dependency.check.formatter.IDependencyCheckFormatter;
import com.github.toolarium.dependency.check.model.DependecyCheckResult;
import com.github.toolarium.dependency.check.model.Dependency;
import com.github.toolarium.dependency.check.model.IncludedBy;
import com.github.toolarium.dependency.check.model.vulnerability.VulnerabilityId;
import com.github.toolarium.dependency.check.model.vulnerability.VulnerableSoftware;
import com.github.toolarium.dependency.check.report.DependencyArtifact;
import com.github.toolarium.dependency.check.report.Vulnerability;
import com.github.toolarium.dependency.check.report.Vulnerability.ScoreType;
import com.github.toolarium.dependency.check.report.VulnerabilityReport;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Format the {@link DependecyCheckResult} into a {@link VulnerabilityReport}.
 *  
 * @author patrick
 */
public class VulnerabilityReportDependecyCheckFormatter implements IDependencyCheckFormatter<VulnerabilityReport> {
    private static final String COLON = ":";
    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportDependecyCheckFormatter.class);

    
    /**
     * Constructor for VulnerabilityReportDependecyCheckFormatter
     */
    public VulnerabilityReportDependecyCheckFormatter() {
    }

    
    /**
     * @see com.github.toolarium.dependency.check.formatter.IDependencyCheckFormatter#format(com.github.toolarium.dependency.check.model.DependecyCheckResult)
     */
    @Override
    public VulnerabilityReport format(DependecyCheckResult dependecyCheckResult) {
        DependencyArtifact projectArtifact = new DependencyArtifact(dependecyCheckResult.getProjectInfo().getGroupID(), dependecyCheckResult.getProjectInfo().getArtifactID(), dependecyCheckResult.getProjectInfo().getVersion());
        VulnerabilityReport vulnerabilityResult = new VulnerabilityReport(dependecyCheckResult.getProjectInfo().getReportDate(), projectArtifact);
        DependecyCheckResult simplifiedDependecyCheckResult = DependencyCheckUtil.getInstance().filter(DependencyCheckUtil.getInstance().simplify(dependecyCheckResult));
        
        for (Dependency d : simplifiedDependecyCheckResult.getDependencies()) {
            for (VulnerabilityDependencyArtifact vulnerabilityDependencyArtifact : convertPackageList(d.getPackages())) {
                com.github.toolarium.dependency.check.report.Dependency dependency = new com.github.toolarium.dependency.check.report.Dependency();
                dependency.setFilename(d.getFileName());
                dependency.setDependencyArtifact(vulnerabilityDependencyArtifact.getDependencyArtifact());
                dependency.setPackageDescription(d.getDescription());
                dependency.setPackageLicence(d.getLicense());
                dependency.setConfidence(vulnerabilityDependencyArtifact.getConfidence()); // HIGHEST
                dependency.setUrl(vulnerabilityDependencyArtifact.getUrl()); // https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&search_type=all&cpe_vendor=cpe%3A%2F%3Afasterxml&cpe_product=cpe%3A%2F%3Afasterxml%3Ajackson-databind&cpe_version=cpe%3A%2F%3Afasterxml%3Ajackson-databind%3A2.15.3

                List<String> configurationList = new ArrayList<String>();
                if (d.getProjectReferences() != null && !d.getProjectReferences().isEmpty()) {
                    for (String projectReference : d.getProjectReferences()) {
                        String[] split = projectReference.split(COLON); // toolarium-system-command:annotationProcessor
                        String name = split[0];
                        String resolveConfiguration = split[1];
                        configurationList.add(resolveConfiguration);
                        dependency.addProjectReferenceList(name);
                    }
                }

                // add included by
                dependency.setIncludedByReferenceList(convertIncludeByList(d.getIncludedBy()));
                
                if (d.getVulnerabilities() != null && !d.getVulnerabilities().isEmpty()) {
                    VulnerabilityId primaryVulnerabilityId = null;
                    Set<String> vulnerabilityIdSet = new HashSet<String>();
                    if (d.getVulnerabilityIds() != null && !d.getVulnerabilityIds().isEmpty()) {
                        for (VulnerabilityId id : d.getVulnerabilityIds()) {
                            if (!vulnerabilityIdSet.contains(id.getId())) {
                                vulnerabilityIdSet.add(parseVulnerabilityArtifactId(id.getId())); // from cpe:2.3:a:fasterxml:jackson-databind:2.15.3:*:*:*:*:*:*:* -> cpe:2.3:a:fasterxml:jackson-databind
                                primaryVulnerabilityId = id;
                                //confidence = id.getConfidence(); // HIGHEST
                                //url = id.getUrl(); // https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&search_type=all&cpe_vendor=cpe%3A%2F%3Afasterxml&cpe_product=cpe%3A%2F%3Afasterxml%3Ajackson-databind&cpe_version=cpe%3A%2F%3Afasterxml%3Ajackson-databind%3A2.15.3
                            }
                        }
                    }
                    
                    
                    Map<String, Vulnerability> vulnerabilityList = new LinkedHashMap<String, Vulnerability>();
                    for (com.github.toolarium.dependency.check.model.vulnerability.Vulnerability v : d.getVulnerabilities()) {
                        String id = v.getName();
                        
                        Vulnerability vulnerability = vulnerabilityList.get(id);
                        boolean update = false;
                        if (vulnerability == null) {
                            vulnerability = new Vulnerability();
                            vulnerability.setCve(v.getName()); // CVE-2020-9493
                            update = true;
                        }

                        if (v.getCvssv2() != null && v.getCvssv2().getScore() != null) {
                            if (v.getCvssv2().getImpactScore() != null) {
                                vulnerability.setImpactScore(v.getCvssv2().getImpactScore());
                            }
                            if (v.getCvssv2().getExploitabilityScore() != null) {
                                vulnerability.setExploitabilityScore(v.getCvssv2().getExploitabilityScore());
                            }
                            
                            vulnerability.setScoreType(Vulnerability.ScoreType.CVSS_V2);
                            vulnerability.setScore(v.getCvssv2().getScore()); // 9.7
                            update = true;
                        }

                        //private String endExcludingVersion; // fixed in
                        if (v.getCvssv3() != null && v.getCvssv3().getBaseScore() != null) {
                            if (vulnerability.getScore() == null || ScoreType.CVSS_V2.equals(vulnerability.getScoreType()) || (vulnerability.getScore().doubleValue() < v.getCvssv3().getBaseScore().doubleValue())) {
                                if (v.getCvssv3().getImpactScore() != null) {
                                    vulnerability.setImpactScore(v.getCvssv3().getImpactScore());
                                }
                                if (v.getCvssv3().getExploitabilityScore() != null) {
                                    vulnerability.setExploitabilityScore(v.getCvssv3().getExploitabilityScore());
                                }
                                
                                vulnerability.setScoreType(Vulnerability.ScoreType.CVSS_V3);
                                vulnerability.setScore(v.getCvssv3().getBaseScore()); // 9.7
                                update = true;
                            }                                
                        }

                        if (update) {
                            VulnerableSoftware matchedVulnerableSoftware = null;
                            if (v.getVulnerableSoftware() != null && !v.getVulnerableSoftware().isEmpty()) {
                                for (VulnerableSoftware vulnerableSoftware : v.getVulnerableSoftware()) {
                                    if (vulnerableSoftware.getSoftware() != null) {
                                        String softwarId = parseVulnerabilityArtifactId(vulnerableSoftware.getSoftware().getId()); // cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:* -< // cpe:2.3:a:fasterxml:jackson-databind
                                        if (vulnerabilityIdSet.contains(softwarId) && "true".equalsIgnoreCase(vulnerableSoftware.getSoftware().getVulnerabilityIdMatched())) { // true
                                            matchedVulnerableSoftware = vulnerableSoftware;
                                        }
                                    }
                                }
                            }
                        
                            vulnerability.setSeverity(v.getSeverity()); // CRITIAL
                            vulnerability.setSource(v.getSource()); // CRITIAL
                            vulnerability.setDescription(v.getDescription()); // "jackson-databind through 2.15.2 allows attackers to cause ...
                            
                            if (matchedVulnerableSoftware != null && matchedVulnerableSoftware.getSoftware() != null) {
                                vulnerability.setEndExcludingVersion(matchedVulnerableSoftware.getSoftware().getVersionEndExcluding()); // 2.16.0    
                            }
                            
                            if (primaryVulnerabilityId != null) {
                                vulnerability.setUrl(primaryVulnerabilityId.getUrl());
                                vulnerability.setConfidence(primaryVulnerabilityId.getConfidence());
                            }

                            vulnerabilityList.put(id, vulnerability);
                        }
                    }
                    
                    List<Vulnerability> preparedVulnerabilityList = new LinkedList<>(vulnerabilityList.values());
                    preparedVulnerabilityList.sort(Comparator.comparing(Vulnerability::getScore).reversed());
                    //preparedVulnerabilityList.forEach(f -> LOG.debug(f.getScore()));                    
                    dependency.setVulnerabilityList(preparedVulnerabilityList);
                }

                LOG.info("Found a vulnerability in [" + vulnerabilityDependencyArtifact.getDependencyArtifact().toArtifactId() + "] in configuration(s): " + configurationList);
                for (String resolveConfiguration : configurationList) {
                    // duplicate for each configuration
                    vulnerabilityResult.add(resolveConfiguration, dependency);
                }
            }
            
        }

        return vulnerabilityResult;
    }


    /**
     * Convert a included by list into a dependency artifact list
     *
     * @param includedByList the included by list
     * @return the dependency artifact list
     */
    protected List<DependencyArtifact> convertIncludeByList(List<IncludedBy> includedByList) {
        List<DependencyArtifact> dependencyArtifactList = new ArrayList<DependencyArtifact>();
        if (includedByList == null || includedByList.isEmpty()) {
            return dependencyArtifactList;
        }
        
        for (IncludedBy includedBy : includedByList) {
            if (includedBy.getReference() != null && !includedBy.getReference().isBlank()) {
                DependencyArtifact dependencyArtifact = parseArtifactId(includedBy.getReference());
                
                if (!dependencyArtifactList.contains(dependencyArtifact)) {
                    dependencyArtifactList.add(dependencyArtifact); // pkg:maven/com.github.toolarium/toolarium-enum-configuration@1.1.8
                }
            }
        }
        
        return dependencyArtifactList;
    }


    /**
     * Convert package list
     *
     * @param packages the packages
     * @return the vulnerability dependency artifact list
     */
    protected List<VulnerabilityDependencyArtifact> convertPackageList(List<com.github.toolarium.dependency.check.model.Package> packages) {
        List<VulnerabilityDependencyArtifact> dependencyArtifactList = new ArrayList<VulnerabilityDependencyArtifact>();
        if (packages == null || packages.isEmpty()) {
            return dependencyArtifactList;
        }
        
        for (com.github.toolarium.dependency.check.model.Package pkg : packages) {
            VulnerabilityDependencyArtifact vulnerabilityDependencyArtifact = new VulnerabilityDependencyArtifact();

            if (pkg.getId() != null && !pkg.getId().isBlank()) {
                vulnerabilityDependencyArtifact.setDependencyArtifact(parseArtifactId(pkg.getId())); // // pkg:maven/com.github.toolarium/toolarium-enum-configuration@1.1.8
            }
            
            vulnerabilityDependencyArtifact.setConfidence(pkg.getConfidence()); // HIGH
            vulnerabilityDependencyArtifact.setUrl(pkg.getUrl()); // https://ossindex.sonatype.org/component/pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.15.3?utm_source=dependency-check&utm_medium=integration&utm_content=9.0.6
            dependencyArtifactList.add(vulnerabilityDependencyArtifact);
        }
        
        return dependencyArtifactList;
    }
    
    
    
    /**
     * Parse artifact id
     *
     * @param input the id
     * @return the parsed artifact
     */
    protected DependencyArtifact parseArtifactId(String input) {
        if (input == null || input.isBlank()) {
            return null;
        }
        
        String[] split = input.trim().split("/"); // pkg:maven/com.github.toolarium/toolarium-enum-configuration@1.1.8
        if (split.length > 2) {
            String groupId = split[1];
            String name = split[2];
            String version = "";
            
            int idx = name.indexOf("@");
            if (idx > 0) {
                version = name.substring(idx + 1);
                name = name.substring(0, idx);
            }
            
            return new DependencyArtifact(groupId, name, version);
        }
        
        LOG.warn("Invalid dependency artifact: " + input + "!");
        return null;
    }
    
    
    /**
     * Parse a vulnerability artifact id
     *
     * @param input the id
     * @return the parsed artifact
     */
    protected String parseVulnerabilityArtifactId(String input) {
        if (input == null || input.isBlank()) {
            return null;
        }
        String[] split = input.trim().split(COLON);
        
        if (split.length > 4) {
            return split[0] + COLON + split[1] + COLON + split[2] + COLON + split[3] + COLON + split[4]; // cpe:2.3:a:fasterxml:jackson-databind
        }
        
        return null;
    }


    /**
     * Defines the vulnerability dependency artifact
     * 
     * @author patrick
     */
    public class VulnerabilityDependencyArtifact {
        private DependencyArtifact dependencyArtifact;
        private String confidence;
        private String url;

        /**
         * Get the dependency artifact of the package
         *
         * @return the dependency artifact of the package
         */
        public DependencyArtifact getDependencyArtifact() {
            return dependencyArtifact;
        }


        /**
         * Set the dependency artifact of the package
         *
         * @param dependencyArtifact the dependency artifact of the package
         */
        public void setDependencyArtifact(DependencyArtifact dependencyArtifact) {
            this.dependencyArtifact = dependencyArtifact;
        }
        
        
        /**
         * Get the confidence
         *
         * @return the confidence
         */
        public String getConfidence() {
            return confidence;
        }
        
        
        /**
         * Set the confidence
         *
         * @param confidence the confidence
         */
        public void setConfidence(String confidence) {
            this.confidence = confidence;
        }


        /**
         * Get the url
         *
         * @return the url
         */
        public String getUrl() {
            return url;
        }
        
        
        /**
         * Set the url
         *
         * @param url the url
         */
        public void setUrl(String url) {
            this.url = url;
        }


        /**
         * @see java.lang.Object#hashCode()
         */
        @Override
        public int hashCode() {
            return Objects.hash(confidence, dependencyArtifact, url);
        }


        /**
         * @see java.lang.Object#equals(java.lang.Object)
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            
            if (obj == null) {
                return false;
            }
            
            if (getClass() != obj.getClass()) {
                return false;
            }
            
            VulnerabilityDependencyArtifact other = (VulnerabilityDependencyArtifact) obj;
            return Objects.equals(confidence, other.confidence)
                    && Objects.equals(dependencyArtifact, other.dependencyArtifact) && Objects.equals(url, other.url);
        }


        /**
         * @see java.lang.Object#toString()
         */
        @Override
        public String toString() {
            return "VulnerabilityDependencyArtifact [dependencyArtifact=" + dependencyArtifact + ", confidence=" + confidence + ", url=" + url + "]";
        }
    }
}
