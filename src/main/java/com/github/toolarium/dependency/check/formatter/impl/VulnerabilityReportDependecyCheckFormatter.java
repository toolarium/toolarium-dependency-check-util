/*
 * VulnerabilityDependecyCheckFormatter.java
 *
 * Copyright by toolarium, all rights reserved.
 */
package com.github.toolarium.dependency.check.formatter.impl;

import com.github.toolarium.dependency.check.DependencyCheckUtil;
import com.github.toolarium.dependency.check.formatter.IDependencyCheckFormatter;
import com.github.toolarium.dependency.check.model.DependecyCheckResult;
import com.github.toolarium.dependency.check.model.Dependency;
import com.github.toolarium.dependency.check.model.IncludedBy;
import com.github.toolarium.dependency.check.model.vulnerability.VulnerabilityId;
import com.github.toolarium.dependency.check.model.vulnerability.VulnerableSoftware;
import com.github.toolarium.dependency.check.report.DependencyArtifact;
import com.github.toolarium.dependency.check.report.Vulnerability;
import com.github.toolarium.dependency.check.report.Vulnerability.ScoreType;
import com.github.toolarium.dependency.check.report.VulnerabilityReport;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Format the {@link DependecyCheckResult} into a {@link VulnerabilityReport}.
 *  
 * @author patrick
 */
public class VulnerabilityReportDependecyCheckFormatter implements IDependencyCheckFormatter<VulnerabilityReport> {
    private static final String COLON = ":";
    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityReportDependecyCheckFormatter.class);

    
    /**
     * Constructor for VulnerabilityReportDependecyCheckFormatter
     */
    public VulnerabilityReportDependecyCheckFormatter() {
    }


    /**
     * @see com.github.toolarium.dependency.check.formatter.IDependencyCheckFormatter#format(com.github.toolarium.dependency.check.model.DependecyCheckResult, com.github.toolarium.dependency.check.formatter.IDependencyCheckFormatter.DependencyFilter)
     */
    @Override
    public VulnerabilityReport format(DependecyCheckResult dependecyCheckResult, DependencyFilter dependencyFilter) {
        DependencyArtifact projectArtifact = new DependencyArtifact(dependecyCheckResult.getProjectInfo().getGroupID(), dependecyCheckResult.getProjectInfo().getArtifactID(), dependecyCheckResult.getProjectInfo().getVersion());
        VulnerabilityReport vulnerabilityResult = new VulnerabilityReport(dependecyCheckResult.getProjectInfo().getReportDate(), projectArtifact);
        DependecyCheckResult simplifiedDependecyCheckResult = DependencyCheckUtil.getInstance().filter(DependencyCheckUtil.getInstance().simplify(dependecyCheckResult));
        
        Map<DependencyArtifact, List<DependencyArtifact>> dependencyMap = new ConcurrentHashMap<DependencyArtifact, List<DependencyArtifact>>();
        List<DependencyArtifact> dependencyList = dependencyMap.get(projectArtifact);
        if (dependencyList == null) {
            dependencyList = new ArrayList<DependencyArtifact>();
            dependencyMap.put(projectArtifact, dependencyList);
        }
        
        for (Dependency d : simplifiedDependecyCheckResult.getDependencies()) {
            for (VulnerabilityDependencyArtifact vulnerabilityDependencyArtifact : convertPackageList(d.getPackages())) {
                com.github.toolarium.dependency.check.report.Dependency dependency = new com.github.toolarium.dependency.check.report.Dependency();
                dependency.setFilename(d.getFileName());
                dependency.setDependencyArtifact(vulnerabilityDependencyArtifact.getDependencyArtifact());
                dependency.setPackageDescription(d.getDescription());
                dependency.setPackageLicence(d.getLicense());
                dependency.setConfidence(vulnerabilityDependencyArtifact.getConfidence()); // HIGHEST
                dependency.setUrl(vulnerabilityDependencyArtifact.getUrl()); // https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&search_type=all&cpe_vendor=cpe%3A%2F%3Afasterxml&cpe_product=cpe%3A%2F%3Afasterxml%3Ajackson-databind&cpe_version=cpe%3A%2F%3Afasterxml%3Ajackson-databind%3A2.15.3

                List<String> configurationList = new ArrayList<String>();
                if (d.getProjectReferences() != null && !d.getProjectReferences().isEmpty()) {
                    for (String projectReference : d.getProjectReferences()) {
                        String[] split = projectReference.split(COLON); // toolarium-system-command:annotationProcessor
                        String name = split[0];
                        String resolveConfiguration = split[1];
                        configurationList.add(resolveConfiguration);
                        dependency.addProjectReferenceList(name);
                    }
                }

                // add included by
                dependency.setIncludedByReferenceList(convertIncludeByList(d.getIncludedBy()));
                
                if (d.getVulnerabilities() != null && !d.getVulnerabilities().isEmpty()) {
                    VulnerabilityId primaryVulnerabilityId = null;
                    Set<String> vulnerabilityIdSet = new HashSet<String>();
                    if (d.getVulnerabilityIds() != null && !d.getVulnerabilityIds().isEmpty()) {
                        for (VulnerabilityId id : d.getVulnerabilityIds()) {
                            if (!vulnerabilityIdSet.contains(id.getId())) {
                                vulnerabilityIdSet.add(parseVulnerabilityArtifactId(id.getId())); // from cpe:2.3:a:fasterxml:jackson-databind:2.15.3:*:*:*:*:*:*:* -> cpe:2.3:a:fasterxml:jackson-databind
                                primaryVulnerabilityId = id;
                                //confidence = id.getConfidence(); // HIGHEST
                                //url = id.getUrl(); // https://nvd.nist.gov/vuln/search/results?form_type=Advanced&results_type=overview&search_type=all&cpe_vendor=cpe%3A%2F%3Afasterxml&cpe_product=cpe%3A%2F%3Afasterxml%3Ajackson-databind&cpe_version=cpe%3A%2F%3Afasterxml%3Ajackson-databind%3A2.15.3
                            }
                        }
                    }
          
                    // prepare report vulnerability
                    Map<String, Vulnerability> vulnerabilityIdList = new LinkedHashMap<String, Vulnerability>();
                    for (com.github.toolarium.dependency.check.model.vulnerability.Vulnerability vulnerability : d.getVulnerabilities()) {
                        final String id = vulnerability.getName();
                        vulnerabilityIdList.put(id, prepareReportVulnerability(primaryVulnerabilityId, vulnerability, vulnerabilityIdList.get(id), vulnerabilityIdSet));
                    }
                    
                    // sort proper
                    List<Vulnerability> preparedVulnerabilityList = new LinkedList<>(vulnerabilityIdList.values());
                    preparedVulnerabilityList.sort(Comparator.comparing(Vulnerability::getScore).reversed());
                    //preparedVulnerabilityList.forEach(f -> LOG.debug(f.getScore()));                    
                    dependency.setVulnerabilityList(preparedVulnerabilityList);
                }

                LOG.debug("Found a vulnerability in [" + vulnerabilityDependencyArtifact.getDependencyArtifact().toArtifactId() + "] in configuration(s): " + configurationList);
                if (vulnerabilityDependencyArtifact.getDependencyArtifact() != null && !dependencyList.contains(vulnerabilityDependencyArtifact.getDependencyArtifact())) {
                    for (DependencyArtifact includedByDependencyArtifact : dependency.getIncludedByReferenceList()) {
                        if (includedByDependencyArtifact.equals(projectArtifact)) {
                            if (!dependencyList.contains(vulnerabilityDependencyArtifact.getDependencyArtifact())) {
                                dependencyList.add(vulnerabilityDependencyArtifact.getDependencyArtifact());
                                LOG.info("Found a direct vulnerability in [ " + projectArtifact.toArtifactId() + " -> [" + vulnerabilityDependencyArtifact.getDependencyArtifact().toArtifactId() + "] in configuration(s): " + configurationList);
                                
                                if (DependencyFilter.DIRECT.equals(dependencyFilter)) {
                                    for (String resolveConfiguration : configurationList) {
                                        // duplicate for each configuration
                                        vulnerabilityResult.add(resolveConfiguration, dependency);
                                    }
                                }
                            }
                        }
                    }
                }
          
                if (DependencyFilter.ALL.equals(dependencyFilter)) {
                    for (String resolveConfiguration : configurationList) {
                        // duplicate for each configuration
                        vulnerabilityResult.add(resolveConfiguration, dependency);
                    }
                }
            }
        }

        return vulnerabilityResult;
    }


    /**
     * Prepare report vulnerability
     * 
     * @param primaryVulnerabilityId the primary vulnerability id
     * @param vulnerability the vulnerability list
     * @param inputReportVulnerability the report vulnerability
     * @param vulnerabilityIdSet the vulnerability id set
     * @return the report vulnerability
     */
    protected Vulnerability prepareReportVulnerability(VulnerabilityId primaryVulnerabilityId, 
                                                       com.github.toolarium.dependency.check.model.vulnerability.Vulnerability vulnerability, 
                                                       Vulnerability inputReportVulnerability,
                                                       Set<String> vulnerabilityIdSet) {
        Vulnerability reportVulnerability = inputReportVulnerability;
        boolean update = false;
        if (reportVulnerability == null) {
            reportVulnerability = new Vulnerability();
            reportVulnerability.setCve(vulnerability.getName()); // CVE-2020-9493
            update = true;
        }

        if (vulnerability.getCvssv2() != null && vulnerability.getCvssv2().getScore() != null) {
            if (vulnerability.getCvssv2().getImpactScore() != null) {
                reportVulnerability.setImpactScore(vulnerability.getCvssv2().getImpactScore());
            }
            if (vulnerability.getCvssv2().getExploitabilityScore() != null) {
                reportVulnerability.setExploitabilityScore(vulnerability.getCvssv2().getExploitabilityScore());
            }
            
            reportVulnerability.setScoreType(Vulnerability.ScoreType.CVSS_V2);
            reportVulnerability.setScore(vulnerability.getCvssv2().getScore()); // 9.7
            update = true;
        }

        //private String endExcludingVersion; // fixed in
        if (vulnerability.getCvssv3() != null && vulnerability.getCvssv3().getBaseScore() != null) {
            if (reportVulnerability.getScore() == null || ScoreType.CVSS_V2.equals(reportVulnerability.getScoreType()) || (reportVulnerability.getScore().doubleValue() < vulnerability.getCvssv3().getBaseScore().doubleValue())) {
                if (vulnerability.getCvssv3().getImpactScore() != null) {
                    reportVulnerability.setImpactScore(vulnerability.getCvssv3().getImpactScore());
                }
                if (vulnerability.getCvssv3().getExploitabilityScore() != null) {
                    reportVulnerability.setExploitabilityScore(vulnerability.getCvssv3().getExploitabilityScore());
                }
                
                reportVulnerability.setScoreType(Vulnerability.ScoreType.CVSS_V3);
                reportVulnerability.setScore(vulnerability.getCvssv3().getBaseScore()); // 9.7
                update = true;
            }                                
        }

        if (update) {
            VulnerableSoftware matchedVulnerableSoftware = null;
            if (vulnerability.getVulnerableSoftware() != null && !vulnerability.getVulnerableSoftware().isEmpty()) {
                for (VulnerableSoftware vulnerableSoftware : vulnerability.getVulnerableSoftware()) {
                    if (vulnerableSoftware.getSoftware() != null) {
                        String softwarId = parseVulnerabilityArtifactId(vulnerableSoftware.getSoftware().getId()); // cpe:2.3:a:fasterxml:jackson-databind:*:*:*:*:*:*:*:* -< // cpe:2.3:a:fasterxml:jackson-databind
                        if (vulnerabilityIdSet.contains(softwarId) && "true".equalsIgnoreCase(vulnerableSoftware.getSoftware().getVulnerabilityIdMatched())) { // true
                            matchedVulnerableSoftware = vulnerableSoftware;
                        }
                    }
                }
            }
        
            reportVulnerability.setSeverity(vulnerability.getSeverity()); // CRITIAL
            reportVulnerability.setSource(vulnerability.getSource()); // CRITIAL
            reportVulnerability.setDescription(vulnerability.getDescription()); // "jackson-databind through 2.15.2 allows attackers to cause ...
            
            if (matchedVulnerableSoftware != null && matchedVulnerableSoftware.getSoftware() != null) {
                reportVulnerability.setEndExcludingVersion(matchedVulnerableSoftware.getSoftware().getVersionEndExcluding()); // 2.16.0    
            }
            
            if (primaryVulnerabilityId != null) {
                reportVulnerability.setUrl(primaryVulnerabilityId.getUrl());
                reportVulnerability.setConfidence(primaryVulnerabilityId.getConfidence());
            }
        }
        
        return reportVulnerability;
    }


    /**
     * Convert a included by list into a dependency artifact list
     *
     * @param includedByList the included by list
     * @return the dependency artifact list
     */
    protected List<DependencyArtifact> convertIncludeByList(List<IncludedBy> includedByList) {
        List<DependencyArtifact> dependencyArtifactList = new ArrayList<DependencyArtifact>();
        if (includedByList == null || includedByList.isEmpty()) {
            return dependencyArtifactList;
        }
        
        for (IncludedBy includedBy : includedByList) {
            if (includedBy.getReference() != null && !includedBy.getReference().isBlank()) {
                DependencyArtifact dependencyArtifact = DependencyArtifact.toDependencyArtifact(includedBy.getReference());
                
                if (!dependencyArtifactList.contains(dependencyArtifact)) {
                    dependencyArtifactList.add(dependencyArtifact); // pkg:maven/com.github.toolarium/toolarium-enum-configuration@1.1.8
                }
            }
        }
        
        return dependencyArtifactList;
    }


    /**
     * Convert package list
     *
     * @param packages the packages
     * @return the vulnerability dependency artifact list
     */
    protected List<VulnerabilityDependencyArtifact> convertPackageList(List<com.github.toolarium.dependency.check.model.Package> packages) {
        List<VulnerabilityDependencyArtifact> dependencyArtifactList = new ArrayList<VulnerabilityDependencyArtifact>();
        if (packages == null || packages.isEmpty()) {
            return dependencyArtifactList;
        }
        
        for (com.github.toolarium.dependency.check.model.Package pkg : packages) {
            VulnerabilityDependencyArtifact vulnerabilityDependencyArtifact = new VulnerabilityDependencyArtifact();

            if (pkg.getId() != null && !pkg.getId().isBlank()) {
                vulnerabilityDependencyArtifact.setDependencyArtifact(DependencyArtifact.toDependencyArtifact(pkg.getId())); // // pkg:maven/com.github.toolarium/toolarium-enum-configuration@1.1.8
            }
            
            vulnerabilityDependencyArtifact.setConfidence(pkg.getConfidence()); // HIGH
            vulnerabilityDependencyArtifact.setUrl(pkg.getUrl()); // https://ossindex.sonatype.org/component/pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.15.3?utm_source=dependency-check&utm_medium=integration&utm_content=9.0.6
            dependencyArtifactList.add(vulnerabilityDependencyArtifact);
        }
        
        return dependencyArtifactList;
    }
    
    
    /**
     * Parse a vulnerability artifact id
     *
     * @param input the id
     * @return the parsed artifact
     */
    protected String parseVulnerabilityArtifactId(String input) {
        if (input == null || input.isBlank()) {
            return null;
        }
        String[] split = input.trim().split(COLON);
        
        if (split.length > 4) {
            return split[0] + COLON + split[1] + COLON + split[2] + COLON + split[3] + COLON + split[4]; // cpe:2.3:a:fasterxml:jackson-databind
        }
        
        return null;
    }


    /**
     * Defines the vulnerability dependency artifact
     * 
     * @author patrick
     */
    public class VulnerabilityDependencyArtifact {
        private DependencyArtifact dependencyArtifact;
        private String confidence;
        private String url;

        /**
         * Get the dependency artifact of the package
         *
         * @return the dependency artifact of the package
         */
        public DependencyArtifact getDependencyArtifact() {
            return dependencyArtifact;
        }


        /**
         * Set the dependency artifact of the package
         *
         * @param dependencyArtifact the dependency artifact of the package
         */
        public void setDependencyArtifact(DependencyArtifact dependencyArtifact) {
            this.dependencyArtifact = dependencyArtifact;
        }
        
        
        /**
         * Get the confidence
         *
         * @return the confidence
         */
        public String getConfidence() {
            return confidence;
        }
        
        
        /**
         * Set the confidence
         *
         * @param confidence the confidence
         */
        public void setConfidence(String confidence) {
            this.confidence = confidence;
        }


        /**
         * Get the url
         *
         * @return the url
         */
        public String getUrl() {
            return url;
        }
        
        
        /**
         * Set the url
         *
         * @param url the url
         */
        public void setUrl(String url) {
            this.url = url;
        }


        /**
         * @see java.lang.Object#hashCode()
         */
        @Override
        public int hashCode() {
            return Objects.hash(confidence, dependencyArtifact, url);
        }


        /**
         * @see java.lang.Object#equals(java.lang.Object)
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            
            if (obj == null) {
                return false;
            }
            
            if (getClass() != obj.getClass()) {
                return false;
            }
            
            VulnerabilityDependencyArtifact other = (VulnerabilityDependencyArtifact) obj;
            return Objects.equals(confidence, other.confidence)
                    && Objects.equals(dependencyArtifact, other.dependencyArtifact) && Objects.equals(url, other.url);
        }


        /**
         * @see java.lang.Object#toString()
         */
        @Override
        public String toString() {
            return "VulnerabilityDependencyArtifact [dependencyArtifact=" + dependencyArtifact + ", confidence=" + confidence + ", url=" + url + "]";
        }
    }
}
